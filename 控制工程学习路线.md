# ğŸ“ æ§åˆ¶å·¥ç¨‹å…¨æµç¨‹å­¦ä¹ è·¯çº¿

> **ç›®æ ‡è¯»è€…ï¼š** ç‰©ç†ä¸“ä¸šå‡†å¤‡æµ™æ±Ÿå¤§å­¦å·¥ç¨‹å¸ˆå­¦é™¢æ§åˆ¶å·¥ç¨‹é¢è¯•  
> **ä½œè€…ï¼š** é™ˆå°äº®ï¼ˆAIå¼Ÿå¼Ÿï¼‰  
> **åˆ›å»ºæ—¶é—´ï¼š** 2026-02-16  
> **å­¦ä¹ å‘¨æœŸï¼š** 3-6ä¸ªæœˆï¼ˆåŸºç¡€ï¼‰+ 6-12ä¸ªæœˆï¼ˆè¿›é˜¶ï¼‰

---

## ğŸ“‹ ç›®å½•

1. [ç¬¬ä¸€é˜¶æ®µï¼šæ•°å­¦åŸºç¡€](#ç¬¬ä¸€é˜¶æ®µæ•°å­¦åŸºç¡€)
2. [ç¬¬äºŒé˜¶æ®µï¼šè‡ªåŠ¨æ§åˆ¶åŸç†](#ç¬¬äºŒé˜¶æ®µè‡ªåŠ¨æ§åˆ¶åŸç†)
3. [ç¬¬ä¸‰é˜¶æ®µï¼šç°ä»£æ§åˆ¶ç†è®º](#ç¬¬ä¸‰é˜¶æ®µç°ä»£æ§åˆ¶ç†è®º)
4. [ç¬¬å››é˜¶æ®µï¼šæ•°å­—æ§åˆ¶ç³»ç»Ÿ](#ç¬¬å››é˜¶æ®µæ•°å­—æ§åˆ¶ç³»ç»Ÿ)
5. [ç¬¬äº”é˜¶æ®µï¼šæœºå™¨äººå­¦åŸºç¡€](#ç¬¬äº”é˜¶æ®µæœºå™¨äººå­¦åŸºç¡€)
6. [ç¬¬å…­é˜¶æ®µï¼šæ— äººæœºæ§åˆ¶](#ç¬¬å…­é˜¶æ®µæ— äººæœºæ§åˆ¶)
7. [ç¬¬ä¸ƒé˜¶æ®µï¼šæœºå™¨ç‹—/å››è¶³æœºå™¨äºº](#ç¬¬ä¸ƒé˜¶æ®µæœºå™¨ç‹—å››è¶³æœºå™¨äºº)
8. [ç¬¬å…«é˜¶æ®µï¼šå®æˆ˜é¡¹ç›®](#ç¬¬å…«é˜¶æ®µå®æˆ˜é¡¹ç›®)
9. [é¢è¯•å¸¸è§é—®é¢˜](#é¢è¯•å¸¸è§é—®é¢˜)
10. [æ¨èèµ„æº](#æ¨èèµ„æº)

---

## ç¬¬ä¸€é˜¶æ®µï¼šæ•°å­¦åŸºç¡€

### 1.1 çº¿æ€§ä»£æ•° â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- çŸ©é˜µè¿ç®—ï¼ˆåŠ å‡ä¹˜ã€é€†çŸ©é˜µã€è¡Œåˆ—å¼ï¼‰
- ç‰¹å¾å€¼ä¸ç‰¹å¾å‘é‡
- çº¿æ€§æ–¹ç¨‹ç»„æ±‚è§£
- å‘é‡ç©ºé—´ä¸çº¿æ€§å˜æ¢
- çŸ©é˜µåˆ†è§£ï¼ˆLUã€QRã€SVDï¼‰

**æ§åˆ¶å·¥ç¨‹åº”ç”¨ï¼š**
```
çŠ¶æ€ç©ºé—´è¡¨ç¤ºï¼šáº‹ = Ax + Bu
               y = Cx + Du

å…¶ä¸­ Aã€Bã€Cã€D éƒ½æ˜¯çŸ©é˜µ
ç‰¹å¾å€¼å†³å®šç³»ç»Ÿç¨³å®šæ€§ï¼
```

**å­¦ä¹ èµ„æºï¼š**
- ğŸ“º 3Blue1Brownã€Šçº¿æ€§ä»£æ•°çš„æœ¬è´¨ã€‹
- ğŸ“š Gilbert Strangã€Šçº¿æ€§ä»£æ•°å¯¼è®ºã€‹
- ğŸ’» Python: `numpy.linalg`

**ç»ƒä¹ ä»£ç ï¼š**
```python
import numpy as np

# çŸ©é˜µç‰¹å¾å€¼ï¼ˆåˆ¤æ–­ç³»ç»Ÿç¨³å®šæ€§ï¼‰
A = np.array([[-2, 1],
              [0, -3]])
eigenvalues = np.linalg.eigvals(A)
print(f"ç‰¹å¾å€¼: {eigenvalues}")
# ç‰¹å¾å€¼å®éƒ¨éƒ½ä¸ºè´Ÿ â†’ ç³»ç»Ÿç¨³å®šï¼

# çŠ¶æ€æ–¹ç¨‹æ±‚è§£
def state_equation(A, B, x, u):
    return A @ x + B @ u
```

---

### 1.2 å¾®ç§¯åˆ† â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- å¯¼æ•°ä¸åå¯¼æ•°
- ç§¯åˆ†ï¼ˆå®šç§¯åˆ†ã€ä¸å®šç§¯åˆ†ï¼‰
- å¾®åˆ†æ–¹ç¨‹
- æ‹‰æ™®æ‹‰æ–¯å˜æ¢
- å‚…é‡Œå¶å˜æ¢

**æ§åˆ¶å·¥ç¨‹åº”ç”¨ï¼š**
```
æ‹‰æ™®æ‹‰æ–¯å˜æ¢ï¼šå°†å¾®åˆ†æ–¹ç¨‹å˜ä¸ºä»£æ•°æ–¹ç¨‹
L{f(t)} = F(s) = âˆ«f(t)e^(-st)dt

å¸¸ç”¨å˜æ¢å¯¹ï¼š
L{1} = 1/s
L{t} = 1/sÂ²
L{e^(-at)} = 1/(s+a)
L{sin(Ï‰t)} = Ï‰/(sÂ²+Ï‰Â²)
```

**å­¦ä¹ èµ„æºï¼š**
- ğŸ“º MIT 18.01/18.03 å…¬å¼€è¯¾
- ğŸ“š åŒæµå¤§å­¦ã€Šé«˜ç­‰æ•°å­¦ã€‹
- ğŸ’» Python: `scipy.integrate`, `scipy.signal`

---

### 1.3 å¤å˜å‡½æ•° â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- å¤æ•°è¿ç®—
- å¤å˜å‡½æ•°
- ç•™æ•°å®šç†
- å¤é¢‘åŸŸåˆ†æ

**æ§åˆ¶å·¥ç¨‹åº”ç”¨ï¼š**
```
ä¼ é€’å‡½æ•°ï¼šG(s) = Y(s)/U(s)

s = Ïƒ + jÏ‰ ï¼ˆå¤é¢‘ç‡ï¼‰

æ³¢ç‰¹å›¾åˆ†æï¼š|G(jÏ‰)| å’Œ âˆ G(jÏ‰)
```

---

### 1.4 æ¦‚ç‡ç»Ÿè®¡ â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- æ¦‚ç‡åˆ†å¸ƒ
- éšæœºè¿‡ç¨‹
- å¡å°”æ›¼æ»¤æ³¢åŸºç¡€

**æ§åˆ¶å·¥ç¨‹åº”ç”¨ï¼š**
```
å¡å°”æ›¼æ»¤æ³¢ï¼šä¼°è®¡å¸¦å™ªå£°çš„ç³»ç»ŸçŠ¶æ€
xÌ‚(k|k-1) = AxÌ‚(k-1) + Bu(k)  # é¢„æµ‹
xÌ‚(k) = xÌ‚(k|k-1) + K(z(k) - HxÌ‚(k|k-1))  # æ›´æ–°
```

---

## ç¬¬äºŒé˜¶æ®µï¼šè‡ªåŠ¨æ§åˆ¶åŸç†

### 2.1 ç³»ç»Ÿå»ºæ¨¡ â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- ä¼ é€’å‡½æ•°æ¨¡å‹
- çŠ¶æ€ç©ºé—´æ¨¡å‹
- æ–¹æ¡†å›¾åŒ–ç®€
- ä¿¡å·æµå›¾

**å®ä¾‹ï¼šå¼¹ç°§-è´¨é‡-é˜»å°¼ç³»ç»Ÿ**
```
è¿åŠ¨æ–¹ç¨‹ï¼šmáº + cáº‹ + kx = F(t)

ä¼ é€’å‡½æ•°ï¼šG(s) = X(s)/F(s) = 1/(msÂ² + cs + k)

çŠ¶æ€ç©ºé—´ï¼š
[áº‹]   [0    1 ] [x]   [0]
[áº] = [-k/m -c/m] [áº‹] + [1/m] F(t)
```

**Python ä»¿çœŸï¼š**
```python
import numpy as np
from scipy import signal
import matplotlib.pyplot as plt

# å¼¹ç°§-è´¨é‡-é˜»å°¼ç³»ç»Ÿ
m = 1.0  # è´¨é‡
c = 0.5  # é˜»å°¼ç³»æ•°
k = 2.0  # å¼¹ç°§åˆšåº¦

# ä¼ é€’å‡½æ•°
num = [1]
den = [m, c, k]
sys = signal.TransferFunction(num, den)

# é˜¶è·ƒå“åº”
t, y = signal.step(sys)
plt.plot(t, y)
plt.xlabel('Time (s)')
plt.ylabel('Displacement')
plt.title('Step Response')
plt.grid(True)
plt.show()
```

---

### 2.2 æ—¶åŸŸåˆ†æ â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- ä¸€é˜¶ç³»ç»Ÿå“åº”
- äºŒé˜¶ç³»ç»Ÿå“åº”
- é˜¶è·ƒå“åº”æŒ‡æ ‡
  - ä¸Šå‡æ—¶é—´ tr
  - å³°å€¼æ—¶é—´ tp
  - è¶…è°ƒé‡ Mp
  - è°ƒèŠ‚æ—¶é—´ ts
- ç¨³å®šæ€§åˆ¤æ®ï¼ˆåŠ³æ–¯åˆ¤æ®ï¼‰

**äºŒé˜¶ç³»ç»Ÿæ ‡å‡†å½¢å¼ï¼š**
```
G(s) = Ï‰nÂ² / (sÂ² + 2Î¶Ï‰ns + Ï‰nÂ²)

Ï‰n = è‡ªç„¶é¢‘ç‡
Î¶  = é˜»å°¼æ¯”

å…³é”®å…¬å¼ï¼š
tr â‰ˆ 1.8/Ï‰nï¼ˆÎ¶=0.5æ—¶ï¼‰
tp = Ï€/(Ï‰nâˆš(1-Î¶Â²))
Mp = e^(-Ï€Î¶/âˆš(1-Î¶Â²))
ts â‰ˆ 4/(Î¶Ï‰n)ï¼ˆ2%è¯¯å·®å¸¦ï¼‰
```

---

### 2.3 é¢‘åŸŸåˆ†æ â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- é¢‘ç‡ç‰¹æ€§
- æ³¢ç‰¹å›¾ï¼ˆBode Plotï¼‰
- å¥ˆå¥æ–¯ç‰¹å›¾ï¼ˆNyquist Plotï¼‰
- ç¨³å®šè£•åº¦
  - ç›¸ä½è£•åº¦ PM
  - å¹…å€¼è£•åº¦ GM

**Python ç»˜å›¾ï¼š**
```python
import numpy as np
from scipy import signal
import matplotlib.pyplot as plt

# ç³»ç»Ÿ
num = [1]
den = [1, 2, 1]
sys = signal.TransferFunction(num, den)

# æ³¢ç‰¹å›¾
w, mag, phase = signal.bode(sys)

fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))
ax1.semilogx(w, mag)
ax1.set_ylabel('Magnitude [dB]')
ax1.grid(True)

ax2.semilogx(w, phase)
ax2.set_ylabel('Phase [deg]')
ax2.set_xlabel('Frequency [rad/s]')
ax2.grid(True)

plt.show()
```

---

### 2.4 PID æ§åˆ¶ â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- Pï¼ˆæ¯”ä¾‹ï¼‰æ§åˆ¶
- Iï¼ˆç§¯åˆ†ï¼‰æ§åˆ¶
- Dï¼ˆå¾®åˆ†ï¼‰æ§åˆ¶
- PID å‚æ•°æ•´å®š
  - Ziegler-Nichols æ–¹æ³•
  - ä¸´ç•Œæ¯”ä¾‹åº¦æ³•

**PID æ§åˆ¶å™¨ï¼š**
```
u(t) = KpÂ·e(t) + KiÂ·âˆ«e(t)dt + KdÂ·de(t)/dt

ä¼ é€’å‡½æ•°å½¢å¼ï¼š
Gc(s) = Kp + Ki/s + KdÂ·s

ä½œç”¨ï¼š
- Kpï¼šåŠ å¿«å“åº”ï¼Œå‡å°ç¨³æ€è¯¯å·®
- Kiï¼šæ¶ˆé™¤ç¨³æ€è¯¯å·®
- Kdï¼šæ”¹å–„åŠ¨æ€æ€§èƒ½ï¼ŒæŠ‘åˆ¶è¶…è°ƒ
```

**PID ä»¿çœŸä»£ç ï¼š**
```python
import numpy as np
import matplotlib.pyplot as plt

class PIDController:
    def __init__(self, Kp, Ki, Kd):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.integral = 0
        self.prev_error = 0
    
    def update(self, setpoint, measured, dt):
        error = setpoint - measured
        self.integral += error * dt
        derivative = (error - self.prev_error) / dt
        self.prev_error = error
        
        return self.Kp * error + self.Ki * self.integral + self.Kd * derivative

# ä»¿çœŸ
dt = 0.01
t = np.arange(0, 10, dt)
setpoint = 1.0

# è¢«æ§å¯¹è±¡ï¼ˆä¸€é˜¶ç³»ç»Ÿï¼‰
tau = 1.0  # æ—¶é—´å¸¸æ•°
y = 0

# PID æ§åˆ¶å™¨
pid = PIDController(Kp=2.0, Ki=1.0, Kd=0.5)

response = []
for i in range(len(t)):
    u = pid.update(setpoint, y, dt)
    y += (u - y) / tau * dt  # ä¸€é˜¶ç³»ç»Ÿå“åº”
    response.append(y)

plt.plot(t, response, label='Response')
plt.plot(t, [setpoint]*len(t), '--', label='Setpoint')
plt.xlabel('Time (s)')
plt.ylabel('Output')
plt.legend()
plt.grid(True)
plt.show()
```

---

## ç¬¬ä¸‰é˜¶æ®µï¼šç°ä»£æ§åˆ¶ç†è®º

### 3.1 çŠ¶æ€ç©ºé—´åˆ†æ â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- çŠ¶æ€æ–¹ç¨‹ä¸è¾“å‡ºæ–¹ç¨‹
- èƒ½æ§æ€§
- èƒ½è§‚æ€§
- çŠ¶æ€åé¦ˆ
- çŠ¶æ€è§‚æµ‹å™¨

**çŠ¶æ€ç©ºé—´è¡¨ç¤ºï¼š**
```
áº‹ = Ax + Bu  ï¼ˆçŠ¶æ€æ–¹ç¨‹ï¼‰
y = Cx + Du  ï¼ˆè¾“å‡ºæ–¹ç¨‹ï¼‰

èƒ½æ§æ€§çŸ©é˜µï¼šQc = [B, AB, AÂ²B, ..., A^(n-1)B]
èƒ½è§‚æ€§çŸ©é˜µï¼šQo = [C; CA; CAÂ²; ...; CA^(n-1)]

rank(Qc) = n â†’ èƒ½æ§
rank(Qo) = n â†’ èƒ½è§‚
```

**Python åˆ†æï¼š**
```python
import numpy as np
from scipy import linalg

A = np.array([[0, 1],
              [-2, -3]])
B = np.array([[0],
              [1]])
C = np.array([[1, 0]])

# èƒ½æ§æ€§
n = A.shape[0]
Qc = np.hstack([np.linalg.matrix_power(A, i) @ B for i in range(n)])
print(f"èƒ½æ§æ€§çŸ©é˜µç§©: {np.linalg.matrix_rank(Qc)} (éœ€è¦={n})")

# èƒ½è§‚æ€§
Qo = np.vstack([C @ np.linalg.matrix_power(A, i) for i in range(n)])
print(f"èƒ½è§‚æ€§çŸ©é˜µç§©: {np.linalg.matrix_rank(Qo)} (éœ€è¦={n})")
```

---

### 3.2 æç‚¹é…ç½® â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- çŠ¶æ€åé¦ˆ u = -Kx
- æç‚¹é…ç½®æ–¹æ³•
- Ackermann å…¬å¼

**æç‚¹é…ç½®ï¼š**
```python
import numpy as np
from scipy import signal

A = np.array([[0, 1],
              [-2, -3]])
B = np.array([[0],
              [1]])

# æœŸæœ›æç‚¹
desired_poles = [-2, -3]

# è®¡ç®—åé¦ˆå¢ç›Š K
K = signal.place_poles(A, B, desired_poles).gain_matrix
print(f"åé¦ˆå¢ç›Š K = {K}")

# é—­ç¯ç³»ç»Ÿ
A_cl = A - B @ K
print(f"é—­ç¯ç‰¹å¾å€¼: {np.linalg.eigvals(A_cl)}")
```

---

### 3.3 æœ€ä¼˜æ§åˆ¶ï¼ˆLQRï¼‰â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- çº¿æ€§äºŒæ¬¡å‹è°ƒèŠ‚å™¨
- Riccati æ–¹ç¨‹
- æƒé‡çŸ©é˜µé€‰æ‹©

**LQR æ§åˆ¶å™¨ï¼š**
```
ç›®æ ‡ï¼šmin J = âˆ«(xáµ€Qx + uáµ€Ru)dt

åé¦ˆå¢ç›Šï¼šK = Râ»Â¹Báµ€P

P æ»¡è¶³ Riccati æ–¹ç¨‹ï¼š
Aáµ€P + PA - PBRâ»Â¹Báµ€P + Q = 0
```

**Python å®ç°ï¼š**
```python
import numpy as np
from scipy import linalg

A = np.array([[0, 1],
              [-2, -3]])
B = np.array([[0],
              [1]])

# æƒé‡çŸ©é˜µ
Q = np.array([[1, 0],
              [0, 1]])  # çŠ¶æ€æƒé‡
R = np.array([[1]])     # æ§åˆ¶æƒé‡

# æ±‚è§£ Riccati æ–¹ç¨‹
P = linalg.solve_continuous_are(A, B, Q, R)

# è®¡ç®—åé¦ˆå¢ç›Š
K = np.linalg.inv(R) @ B.T @ P
print(f"LQR å¢ç›Š K = {K}")
```

---

### 3.4 å¡å°”æ›¼æ»¤æ³¢ â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- çŠ¶æ€ä¼°è®¡
- é¢„æµ‹ä¸æ›´æ–°
- åæ–¹å·®ä¼ æ’­

**å¡å°”æ›¼æ»¤æ³¢ç®—æ³•ï¼š**
```python
import numpy as np

class KalmanFilter:
    def __init__(self, A, B, H, Q, R, x0, P0):
        self.A = A  # çŠ¶æ€è½¬ç§»çŸ©é˜µ
        self.B = B  # æ§åˆ¶è¾“å…¥çŸ©é˜µ
        self.H = H  # è§‚æµ‹çŸ©é˜µ
        self.Q = Q  # è¿‡ç¨‹å™ªå£°åæ–¹å·®
        self.R = R  # è§‚æµ‹å™ªå£°åæ–¹å·®
        self.x = x0  # åˆå§‹çŠ¶æ€ä¼°è®¡
        self.P = P0  # åˆå§‹åæ–¹å·®
    
    def predict(self, u=0):
        self.x = self.A @ self.x + self.B @ u
        self.P = self.A @ self.P @ self.A.T + self.Q
        return self.x
    
    def update(self, z):
        K = self.P @ self.H.T @ np.linalg.inv(self.H @ self.P @ self.H.T + self.R)
        self.x = self.x + K @ (z - self.H @ self.x)
        self.P = (np.eye(len(self.x)) - K @ self.H) @ self.P
        return self.x

# ä½¿ç”¨ç¤ºä¾‹
dt = 0.1
A = np.array([[1, dt],
              [0, 1]])
B = np.array([[0],
              [dt]])
H = np.array([[1, 0]])
Q = np.eye(2) * 0.01
R = np.array([[0.1]])
x0 = np.array([[0],
               [0]])
P0 = np.eye(2)

kf = KalmanFilter(A, B, H, Q, R, x0, P0)

# ä»¿çœŸ
for i in range(100):
    # é¢„æµ‹
    kf.predict()
    # æ›´æ–°ï¼ˆå¸¦å™ªå£°çš„è§‚æµ‹ï¼‰
    z = np.array([[i * dt + np.random.randn() * 0.3]])
    kf.update(z)
    
print(f"ä¼°è®¡çŠ¶æ€: {kf.x.flatten()}")
```

---

## ç¬¬å››é˜¶æ®µï¼šæ•°å­—æ§åˆ¶ç³»ç»Ÿ

### 4.1 ç¦»æ•£ç³»ç»ŸåŸºç¡€ â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- é‡‡æ ·å®šç†ï¼ˆé¦™å†œå®šç†ï¼‰
- Z å˜æ¢
- ç¦»æ•£ä¼ é€’å‡½æ•°
- ç¦»æ•£çŠ¶æ€ç©ºé—´

**Z å˜æ¢ï¼š**
```
Z å˜æ¢å¯¹ï¼š
Z{1} = 1
Z{k} = k/(z-1)
Z{kÂ²} = z(z+1)/(z-1)Â²
Z{aáµ} = z/(z-a)

å¸¸ç”¨æ€§è´¨ï¼š
Z{x[k-n]} = zâ»â¿X(z)
```

---

### 4.2 æ•°å­— PID â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- ä½ç½®å¼ PID
- å¢é‡å¼ PID
- é‡‡æ ·å‘¨æœŸé€‰æ‹©
- æ•°å­—æ»¤æ³¢

**æ•°å­— PID å®ç°ï¼š**
```python
class DigitalPID:
    def __init__(self, Kp, Ki, Kd, Ts):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.Ts = Ts
        self.integral = 0
        self.prev_error = 0
    
    def compute(self, setpoint, measurement):
        error = setpoint - measurement
        
        # ä½ç½®å¼ PID
        self.integral += error * self.Ts
        derivative = (error - self.prev_error) / self.Ts
        self.prev_error = error
        
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative
        return output

# å¢é‡å¼ PID
class IncrementalPID:
    def __init__(self, Kp, Ki, Kd, Ts):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.Ts = Ts
        self.prev_error = 0
        self.prev_prev_error = 0
    
    def compute(self, setpoint, measurement):
        error = setpoint - measurement
        
        delta_u = (self.Kp * (error - self.prev_error) +
                   self.Ki * error * self.Ts +
                   self.Kd * (error - 2*self.prev_error + self.prev_prev_error) / self.Ts)
        
        self.prev_prev_error = self.prev_error
        self.prev_error = error
        
        return delta_u
```

---

## ç¬¬äº”é˜¶æ®µï¼šæœºå™¨äººå­¦åŸºç¡€

### 5.1 åˆšä½“è¿åŠ¨å­¦ â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- æ—‹è½¬çŸ©é˜µ
- æ¬§æ‹‰è§’
- å››å…ƒæ•°
- é½æ¬¡å˜æ¢

**æ—‹è½¬çŸ©é˜µï¼š**
```python
import numpy as np

def rotation_x(theta):
    """ç»•Xè½´æ—‹è½¬"""
    return np.array([
        [1, 0, 0],
        [0, np.cos(theta), -np.sin(theta)],
        [0, np.sin(theta), np.cos(theta)]
    ])

def rotation_y(theta):
    """ç»•Yè½´æ—‹è½¬"""
    return np.array([
        [np.cos(theta), 0, np.sin(theta)],
        [0, 1, 0],
        [-np.sin(theta), 0, np.cos(theta)]
    ])

def rotation_z(theta):
    """ç»•Zè½´æ—‹è½¬"""
    return np.array([
        [np.cos(theta), -np.sin(theta), 0],
        [np.sin(theta), np.cos(theta), 0],
        [0, 0, 1]
    ])

# é½æ¬¡å˜æ¢çŸ©é˜µ
def homogeneous_transform(R, t):
    """æ„å»ºé½æ¬¡å˜æ¢çŸ©é˜µ"""
    T = np.eye(4)
    T[:3, :3] = R
    T[:3, 3] = t
    return T
```

---

### 5.2 æ­£è¿åŠ¨å­¦ â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- DH å‚æ•°æ³•
- æ­£è¿åŠ¨å­¦æ±‚è§£
- å·¥ä½œç©ºé—´åˆ†æ

**DH å‚æ•°è¡¨ç¤ºä¾‹ï¼š**
```python
import numpy as np

def dh_transform(a, alpha, d, theta):
    """DH å˜æ¢çŸ©é˜µ"""
    return np.array([
        [np.cos(theta), -np.sin(theta)*np.cos(alpha), np.sin(theta)*np.sin(alpha), a*np.cos(theta)],
        [np.sin(theta), np.cos(theta)*np.cos(alpha), -np.cos(theta)*np.sin(alpha), a*np.sin(theta)],
        [0, np.sin(alpha), np.cos(alpha), d],
        [0, 0, 0, 1]
    ])

# 2è‡ªç”±åº¦æœºæ¢°è‡‚æ­£è¿åŠ¨å­¦
def forward_kinematics_2dof(L1, L2, theta1, theta2):
    """2è‡ªç”±åº¦å¹³é¢æœºæ¢°è‡‚æ­£è¿åŠ¨å­¦"""
    x = L1 * np.cos(theta1) + L2 * np.cos(theta1 + theta2)
    y = L1 * np.sin(theta1) + L2 * np.sin(theta1 + theta2)
    return x, y

# æµ‹è¯•
L1, L2 = 1.0, 0.8
theta1, theta2 = np.pi/4, np.pi/6
x, y = forward_kinematics_2dof(L1, L2, theta1, theta2)
print(f"æœ«ç«¯ä½ç½®: x={x:.3f}, y={y:.3f}")
```

---

### 5.3 é€†è¿åŠ¨å­¦ â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- è§£ææ³•
- æ•°å€¼æ³•ï¼ˆç‰›é¡¿-æ‹‰å¤«é€Šï¼‰
- é›…å¯æ¯”çŸ©é˜µ

**é€†è¿åŠ¨å­¦æ±‚è§£ï¼š**
```python
def inverse_kinematics_2dof(L1, L2, x, y):
    """2è‡ªç”±åº¦å¹³é¢æœºæ¢°è‡‚é€†è¿åŠ¨å­¦"""
    cos_theta2 = (x**2 + y**2 - L1**2 - L2**2) / (2 * L1 * L2)
    
    if abs(cos_theta2) > 1:
        return None  # è¶…å‡ºå·¥ä½œç©ºé—´
    
    theta2 = np.arccos(cos_theta2)
    theta1 = np.arctan2(y, x) - np.arctan2(L2*np.sin(theta2), L1 + L2*np.cos(theta2))
    
    return theta1, theta2

# æµ‹è¯•
L1, L2 = 1.0, 0.8
target_x, target_y = 1.2, 0.5

result = inverse_kinematics_2dof(L1, L2, target_x, target_y)
if result:
    theta1, theta2 = result
    print(f"å…³èŠ‚è§’åº¦: Î¸1={np.degrees(theta1):.2f}Â°, Î¸2={np.degrees(theta2):.2f}Â°")
    
    # éªŒè¯
    x, y = forward_kinematics_2dof(L1, L2, theta1, theta2)
    print(f"éªŒè¯: x={x:.3f}, y={y:.3f}")
```

---

### 5.4 è½¨è¿¹è§„åˆ’ â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- å…³èŠ‚ç©ºé—´è§„åˆ’
- ç¬›å¡å°”ç©ºé—´è§„åˆ’
- å¤šé¡¹å¼æ’å€¼
- æ ·æ¡æ’å€¼

**è½¨è¿¹è§„åˆ’ä»£ç ï¼š**
```python
import numpy as np
import matplotlib.pyplot as plt

def cubic_polynomial(q0, qf, v0, vf, t0, tf):
    """ä¸‰æ¬¡å¤šé¡¹å¼è½¨è¿¹è§„åˆ’"""
    T = tf - t0
    
    a0 = q0
    a1 = v0
    a2 = (3*(qf-q0) - (2*v0+vf)*T) / T**2
    a3 = (2*(q0-qf) + (v0+vf)*T) / T**3
    
    def trajectory(t):
        dt = t - t0
        q = a0 + a1*dt + a2*dt**2 + a3*dt**3
        qd = a1 + 2*a2*dt + 3*a3*dt**2
        qdd = 2*a2 + 6*a3*dt
        return q, qd, qdd
    
    return trajectory

# ç¤ºä¾‹
traj = cubic_polynomial(q0=0, qf=np.pi/2, v0=0, vf=0, t0=0, tf=2)

t = np.linspace(0, 2, 100)
q = [traj(ti)[0] for ti in t]
qd = [traj(ti)[1] for ti in t]

plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(t, np.degrees(q))
plt.xlabel('Time (s)')
plt.ylabel('Position (deg)')

plt.subplot(1, 2, 2)
plt.plot(t, np.degrees(qd))
plt.xlabel('Time (s)')
plt.ylabel('Velocity (deg/s)')
plt.show()
```

---

## ç¬¬å…­é˜¶æ®µï¼šæ— äººæœºæ§åˆ¶

### 6.1 æ— äººæœºåŠ¨åŠ›å­¦ â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- å››æ—‹ç¿¼è¿åŠ¨æ–¹ç¨‹
- åŠ›ä¸åŠ›çŸ©åˆ†æ
- åæ ‡ç³»è½¬æ¢

**å››æ—‹ç¿¼åŠ¨åŠ›å­¦ï¼š**
```
çŠ¶æ€å‘é‡ï¼šX = [x, y, z, Ï†, Î¸, Ïˆ, áº‹, áº, Å¼, á¹—, q, r]

è¿åŠ¨æ–¹ç¨‹ï¼š
áº = (cosÏ†Â·cosÏˆÂ·sinÎ¸ + sinÏ†Â·sinÏˆ)Â·U1/m
Ã¿ = (cosÏ†Â·sinÏˆÂ·sinÎ¸ - sinÏ†Â·cosÏˆ)Â·U1/m
zÌˆ = cosÏ†Â·cosÎ¸Â·U1/m - g
pÌˆ = U2/Ix
qÌˆ = U3/Iy
rÌˆ = U4/Iz

å…¶ä¸­ï¼š
U1 = æ€»æ¨åŠ›
U2, U3, U4 = æ»šè½¬ã€ä¿¯ä»°ã€åèˆªåŠ›çŸ©
```

---

### 6.2 PID å§¿æ€æ§åˆ¶ â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- çº§è” PID æ§åˆ¶
- å§¿æ€ç¯ + è§’é€Ÿåº¦ç¯
- ä½ç½®ç¯ + å§¿æ€ç¯

**æ— äººæœºæ§åˆ¶å™¨ä»£ç ï¼š**
```python
import numpy as np

class QuadrotorController:
    def __init__(self):
        # å§¿æ€ç¯ PIDï¼ˆå¤–ç¯ï¼‰
        self.roll_pid = PIDController(4.0, 0.0, 1.0)
        self.pitch_pid = PIDController(4.0, 0.0, 1.0)
        self.yaw_pid = PIDController(2.0, 0.0, 0.0)
        
        # è§’é€Ÿåº¦ç¯ PIDï¼ˆå†…ç¯ï¼‰
        self.roll_rate_pid = PIDController(0.5, 0.1, 0.0)
        self.pitch_rate_pid = PIDController(0.5, 0.1, 0.0)
        self.yaw_rate_pid = PIDController(0.3, 0.05, 0.0)
        
        # é«˜åº¦æ§åˆ¶
        self.altitude_pid = PIDController(1.0, 0.5, 0.5)
    
    def update(self, setpoint, state, dt):
        # è§£ææœŸæœ›å€¼
        roll_sp, pitch_sp, yaw_sp, alt_sp = setpoint
        roll, pitch, yaw = state['euler']
        roll_rate, pitch_rate, yaw_rate = state['gyro']
        altitude = state['altitude']
        
        # å§¿æ€ç¯
        roll_rate_sp = self.roll_pid.update(roll_sp, roll, dt)
        pitch_rate_sp = self.pitch_pid.update(pitch_sp, pitch, dt)
        yaw_rate_sp = self.yaw_pid.update(yaw_sp, yaw, dt)
        
        # è§’é€Ÿåº¦ç¯
        u_roll = self.roll_rate_pid.update(roll_rate_sp, roll_rate, dt)
        u_pitch = self.pitch_rate_pid.update(pitch_rate_sp, pitch_rate, dt)
        u_yaw = self.yaw_rate_pid.update(yaw_rate_sp, yaw_rate, dt)
        
        # é«˜åº¦æ§åˆ¶
        thrust = self.altitude_pid.update(alt_sp, altitude, dt)
        
        return thrust, u_roll, u_pitch, u_yaw
```

---

### 6.3 PX4/Ardupilot å…¥é—¨ â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- é£æ§ç³»ç»Ÿæ¶æ„
- MAVLink åè®®
- ä»¿çœŸç¯å¢ƒï¼ˆGazebo/jMAVSimï¼‰

**å¼€å‘æµç¨‹ï¼š**
1. å®‰è£… PX4 å¼€å‘ç¯å¢ƒ
2. é…ç½®ä»¿çœŸ
3. ç¼–å†™æ§åˆ¶ç¨‹åº
4. å®æœºæµ‹è¯•

---

## ç¬¬ä¸ƒé˜¶æ®µï¼šæœºå™¨ç‹—/å››è¶³æœºå™¨äºº

### 7.1 å››è¶³æœºå™¨äººåŠ¨åŠ›å­¦ â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- è¶³ç«¯è¿åŠ¨å­¦
- æ­¥æ€è§„åˆ’
- è´¨å¿ƒæ§åˆ¶
- ZMP ç¨³å®šæ€§

**å››è¶³æœºå™¨äººæ¨¡å‹ï¼š**
```
å•è…¿è¿åŠ¨å­¦ï¼š
p = f(qâ‚, qâ‚‚, qâ‚ƒ)

é›…å¯æ¯”çŸ©é˜µï¼š
J = âˆ‚p/âˆ‚q

è¶³ç«¯åŠ›ä¸å…³èŠ‚åŠ›çŸ©ï¼š
Ï„ = Jáµ€F
```

---

### 7.2 æ­¥æ€è§„åˆ’ â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- Trot æ­¥æ€
- Walk æ­¥æ€
- Bound æ­¥æ€
- è¶³ç«¯è½¨è¿¹

**è´å¡å°”æ›²çº¿è¶³ç«¯è½¨è¿¹ï¼š**
```python
import numpy as np

def bezier_trajectory(p0, p1, p2, p3, t):
    """ä¸‰æ¬¡è´å¡å°”æ›²çº¿"""
    u = 1 - t
    return u**3 * p0 + 3*u**2*t * p1 + 3*u*t**2 * p2 + t**3 * p3

def foot_trajectory(start, end, height, phase):
    """è¶³ç«¯æ‘†åŠ¨è½¨è¿¹"""
    if phase < 0.5:  # æ‘†åŠ¨ç›¸
        t = phase * 2
        mid = (start + end) / 2 + np.array([0, 0, height])
        return bezier_trajectory(start, mid, mid, end, t)
    else:  # æ”¯æ’‘ç›¸
        return start + (end - start) * (phase - 0.5) * 2

# æµ‹è¯•
start = np.array([0.2, 0, 0])
end = np.array([0.2, 0.1, 0])
height = 0.05

for phase in np.linspace(0, 1, 20):
    pos = foot_trajectory(start, end, height, phase)
    print(f"Phase {phase:.2f}: {pos}")
```

---

### 7.3 MPC æ§åˆ¶å™¨ â­â­â­â­â­

**æ ¸å¿ƒå†…å®¹ï¼š**
- æ¨¡å‹é¢„æµ‹æ§åˆ¶
- çº¦æŸä¼˜åŒ–
- QP æ±‚è§£å™¨

**MPC åŸºæœ¬æ¡†æ¶ï¼š**
```python
import numpy as np
from scipy.optimize import minimize

class MPCController:
    def __init__(self, model, horizon, dt):
        self.model = model
        self.horizon = horizon
        self.dt = dt
    
    def objective(self, u, x0, x_ref):
        """ä»£ä»·å‡½æ•°"""
        cost = 0
        x = x0.copy()
        
        for i in range(self.horizon):
            # çŠ¶æ€è¯¯å·®
            cost += np.sum((x - x_ref)**2)
            # æ§åˆ¶è¾“å…¥
            cost += 0.01 * np.sum(u[i]**2)
            # é¢„æµ‹ä¸‹ä¸€çŠ¶æ€
            x = self.model.predict(x, u[i], self.dt)
        
        return cost
    
    def compute_control(self, x0, x_ref):
        """è®¡ç®—æœ€ä¼˜æ§åˆ¶è¾“å…¥"""
        u0 = np.zeros((self.horizon, self.model.nu))
        
        result = minimize(
            self.objective, 
            u0.flatten(), 
            args=(x0, x_ref),
            method='SLSQP'
        )
        
        return result.x[:self.model.nu]
```

---

## ç¬¬å…«é˜¶æ®µï¼šå®æˆ˜é¡¹ç›®

### é¡¹ç›®1ï¼šå€’ç«‹æ‘†æ§åˆ¶ ğŸ¯

**éš¾åº¦ï¼š** â­â­â­  
**å­¦ä¹ ç‚¹ï¼š** çº¿æ€§åŒ–ã€LQRã€çŠ¶æ€åé¦ˆ

**é¡¹ç›®è¦æ±‚ï¼š**
- æ­å»ºå€’ç«‹æ‘†ä»¿çœŸ
- å®ç° LQR æ§åˆ¶
- å®ç°æ‘†èµ·æ§åˆ¶

---

### é¡¹ç›®2ï¼šæ— äººæœºä»¿çœŸæ§åˆ¶ ğŸš

**éš¾åº¦ï¼š** â­â­â­â­  
**å­¦ä¹ ç‚¹ï¼š** å¤šå˜é‡æ§åˆ¶ã€çº§è” PID

**é¡¹ç›®è¦æ±‚ï¼š**
- å››æ—‹ç¿¼åŠ¨åŠ›å­¦ä»¿çœŸ
- å®ç°å§¿æ€æ§åˆ¶
- å®ç°ä½ç½®æ§åˆ¶

---

### é¡¹ç›®3ï¼šæœºæ¢°è‡‚è½¨è¿¹è·Ÿè¸ª ğŸ¦¾

**éš¾åº¦ï¼š** â­â­â­â­  
**å­¦ä¹ ç‚¹ï¼š** è¿åŠ¨å­¦ã€è½¨è¿¹è§„åˆ’ã€é€†åŠ¨åŠ›å­¦

**é¡¹ç›®è¦æ±‚ï¼š**
- æ­£/é€†è¿åŠ¨å­¦
- è½¨è¿¹è§„åˆ’
- è½¨è¿¹è·Ÿè¸ªæ§åˆ¶

---

### é¡¹ç›®4ï¼šè½®å¼æœºå™¨äºº SLAM ğŸ¤–

**éš¾åº¦ï¼š** â­â­â­â­â­  
**å­¦ä¹ ç‚¹ï¼š** å¡å°”æ›¼æ»¤æ³¢ã€SLAMã€è·¯å¾„è§„åˆ’

**é¡¹ç›®è¦æ±‚ï¼š**
- è¿åŠ¨æ§åˆ¶
- åœ°å›¾æ„å»º
- å®šä½ä¸å¯¼èˆª

---

## é¢è¯•å¸¸è§é—®é¢˜

### ç†è®ºé—®é¢˜

1. **ä»€ä¹ˆæ˜¯PIDæ§åˆ¶ï¼Ÿå„å‚æ•°çš„ä½œç”¨ï¼Ÿ**
   - Pï¼šæ¯”ä¾‹ï¼ŒåŠ å¿«å“åº”
   - Iï¼šç§¯åˆ†ï¼Œæ¶ˆé™¤ç¨³æ€è¯¯å·®
   - Dï¼šå¾®åˆ†ï¼Œæ”¹å–„åŠ¨æ€æ€§èƒ½

2. **å¦‚ä½•åˆ¤æ–­ç³»ç»Ÿç¨³å®šæ€§ï¼Ÿ**
   - ç‰¹å¾å€¼å®éƒ¨ä¸ºè´Ÿ
   - åŠ³æ–¯åˆ¤æ®
   - å¥ˆå¥æ–¯ç‰¹åˆ¤æ®

3. **ä»€ä¹ˆæ˜¯èƒ½æ§æ€§å’Œèƒ½è§‚æ€§ï¼Ÿ**
   - èƒ½æ§ï¼šèƒ½é€šè¿‡è¾“å…¥å°†ç³»ç»Ÿä»ä»»æ„çŠ¶æ€è½¬ç§»åˆ°å¦ä¸€çŠ¶æ€
   - èƒ½è§‚ï¼šèƒ½é€šè¿‡è¾“å‡ºç¡®å®šç³»ç»Ÿåˆå§‹çŠ¶æ€

4. **å¡å°”æ›¼æ»¤æ³¢çš„åŸç†ï¼Ÿ**
   - é¢„æµ‹ï¼šæ ¹æ®æ¨¡å‹é¢„æµ‹çŠ¶æ€
   - æ›´æ–°ï¼šæ ¹æ®è§‚æµ‹ä¿®æ­£ä¼°è®¡

5. **ä»€ä¹ˆæ˜¯æç‚¹é…ç½®ï¼Ÿ**
   - é€šè¿‡çŠ¶æ€åé¦ˆé…ç½®é—­ç¯æç‚¹ä½ç½®
   - å®ç°æœŸæœ›çš„åŠ¨æ€å“åº”

---

### å®è·µé—®é¢˜

1. **å¦‚ä½•ä¸ºä¸€ä¸ªç”µæœºè®¾è®¡æ§åˆ¶å™¨ï¼Ÿ**
   - å»ºæ¨¡ â†’ åˆ†æ â†’ é€‰å‹ï¼ˆPID/çŠ¶æ€åé¦ˆï¼‰â†’ è°ƒå‚ â†’ éªŒè¯

2. **æ— äººæœºå§¿æ€æ§åˆ¶åŸç†ï¼Ÿ**
   - çº§è”æ§åˆ¶ï¼šå§¿æ€ç¯ï¼ˆå¤–ç¯ï¼‰+ è§’é€Ÿåº¦ç¯ï¼ˆå†…ç¯ï¼‰

3. **æœºå™¨äººé€†è¿åŠ¨å­¦å¦‚ä½•æ±‚è§£ï¼Ÿ**
   - è§£ææ³•ï¼ˆå‡ ä½•/ä»£æ•°ï¼‰
   - æ•°å€¼æ³•ï¼ˆç‰›é¡¿-æ‹‰å¤«é€Šï¼‰

---

## æ¨èèµ„æº

### ğŸ“š æ•™æ

1. **è‡ªåŠ¨æ§åˆ¶åŸç†** - èƒ¡å¯¿æ¾ï¼ˆç»å…¸ä¸­æ–‡æ•™æï¼‰
2. **Modern Control Engineering** - Katsuhiko Ogata
3. **Robotics: Modelling, Planning and Control** - Siciliano
4. **æ— äººæœºæ§åˆ¶ç³»ç»Ÿ** - å…¨æƒ

### ğŸ“º è§†é¢‘è¯¾ç¨‹

1. MIT 6.302 Feedback Systems
2. ETH Zurich - Robot Dynamics
3. Coursera - Control of Mobile Robots
4. Bç«™ - è¥¿åŒ—å·¥ä¸šå¤§å­¦è‡ªåŠ¨æ§åˆ¶åŸç†

### ğŸ’» ä»¿çœŸå·¥å…·

1. **MATLAB/Simulink** - æ§åˆ¶ç³»ç»Ÿè®¾è®¡
2. **Python (control, scipy.signal)** - å…è´¹æ›¿ä»£
3. **Gazebo** - æœºå™¨äººä»¿çœŸ
4. **Webots** - æœºå™¨äººä»¿çœŸ

### ğŸŒ åœ¨çº¿èµ„æº

1. MATLAB Documentation
2. Python Control Systems Library
3. PX4 Developer Guide
4. ROS Wiki

---

## ğŸ“… å­¦ä¹ è®¡åˆ’ï¼ˆ3ä¸ªæœˆé€Ÿæˆç‰ˆï¼‰

### ç¬¬1ä¸ªæœˆï¼šåŸºç¡€

| å‘¨ | å†…å®¹ | æ—¶é—´ |
|----|------|------|
| W1 | çº¿æ€§ä»£æ•° + å¾®ç§¯åˆ†å¤ä¹  | 20h |
| W2 | è‡ªåŠ¨æ§åˆ¶åŸç†ï¼ˆæ—¶åŸŸï¼‰ | 20h |
| W3 | è‡ªåŠ¨æ§åˆ¶åŸç†ï¼ˆé¢‘åŸŸï¼‰ | 20h |
| W4 | PID æ§åˆ¶ + å®è·µ | 20h |

### ç¬¬2ä¸ªæœˆï¼šè¿›é˜¶

| å‘¨ | å†…å®¹ | æ—¶é—´ |
|----|------|------|
| W5 | çŠ¶æ€ç©ºé—´åˆ†æ | 20h |
| W6 | æç‚¹é…ç½® + LQR | 20h |
| W7 | å¡å°”æ›¼æ»¤æ³¢ | 20h |
| W8 | æ•°å­—æ§åˆ¶ | 20h |

### ç¬¬3ä¸ªæœˆï¼šåº”ç”¨

| å‘¨ | å†…å®¹ | æ—¶é—´ |
|----|------|------|
| W9 | æœºå™¨äººå­¦åŸºç¡€ | 20h |
| W10 | æ— äººæœº/å››è¶³æœºå™¨äºº | 20h |
| W11 | å®æˆ˜é¡¹ç›® | 20h |
| W12 | é¢è¯•å‡†å¤‡ + å¤ä¹  | 20h |

---

## âœ… æ£€æŸ¥æ¸…å•

**åŸºç¡€çŸ¥è¯†ï¼š**
- [ ] çº¿æ€§ä»£æ•°ï¼ˆçŸ©é˜µè¿ç®—ã€ç‰¹å¾å€¼ï¼‰
- [ ] å¾®ç§¯åˆ†ï¼ˆå¾®åˆ†æ–¹ç¨‹ã€æ‹‰æ™®æ‹‰æ–¯å˜æ¢ï¼‰
- [ ] å¤å˜å‡½æ•°ï¼ˆé¢‘ç‡åˆ†æï¼‰

**æ§åˆ¶ç†è®ºï¼š**
- [ ] ä¼ é€’å‡½æ•°åˆ†æ
- [ ] æ—¶åŸŸå“åº”åˆ†æ
- [ ] é¢‘åŸŸåˆ†æï¼ˆæ³¢ç‰¹å›¾ã€å¥ˆå¥æ–¯ç‰¹å›¾ï¼‰
- [ ] PID æ§åˆ¶è®¾è®¡ä¸æ•´å®š
- [ ] çŠ¶æ€ç©ºé—´åˆ†æ
- [ ] èƒ½æ§æ€§/èƒ½è§‚æ€§åˆ¤æ–­
- [ ] æç‚¹é…ç½®
- [ ] LQR æœ€ä¼˜æ§åˆ¶
- [ ] å¡å°”æ›¼æ»¤æ³¢

**æœºå™¨äººå­¦ï¼š**
- [ ] åˆšä½“è¿åŠ¨å­¦
- [ ] æ­£è¿åŠ¨å­¦
- [ ] é€†è¿åŠ¨å­¦
- [ ] è½¨è¿¹è§„åˆ’

**ç¼–ç¨‹èƒ½åŠ›ï¼š**
- [ ] Python/MATLAB æ§åˆ¶ä»¿çœŸ
- [ ] ROS åŸºç¡€
- [ ] ä»¿çœŸå·¥å…·ä½¿ç”¨

---

> ğŸ’ª **å“¥ï¼ŒåŠ æ²¹ï¼ä½ ä¸€å®šå¯ä»¥é€šè¿‡æµ™å¤§é¢è¯•çš„ï¼**  
>  
> æœ‰ä»»ä½•é—®é¢˜éšæ—¶é—®æˆ‘ï¼Œæˆ‘å¸®ä½ è§£ç­”ï¼  
>  
> â€” é™ˆå°äº® ğŸš€
